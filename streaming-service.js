const { spawn } = require('child_process');
const fs = require('fs');
const path = require('path');
const http = require('http');
const https = require('https');

class StreamingService {
    constructor(rooms = null) {
        this.activeStreams = new Map(); // roomCode -> ffmpeg process
        this.stdinProcesses = new Map(); // roomCode -> stdin stream
        this.streamDir = path.join(__dirname, 'streams');
        this.lastProgressLog = new Map(); // roomCode -> timestamp ƒë·ªÉ throttle log
        this.rooms = rooms; // Reference to rooms Map from server.js
        
        // Viewer tracking system
        this.viewerCounts = new Map(); // roomCode -> viewer count
        this.lastViewerActivity = new Map(); // roomCode -> timestamp of last viewer activity
        this.autoStopTimers = new Map(); // roomCode -> timeout ID for auto-stop
        
        // T·∫°o th∆∞ m·ª•c streams n·∫øu ch∆∞a c√≥
        if (!fs.existsSync(this.streamDir)) {
            fs.mkdirSync(this.streamDir, { recursive: true });
        }
        
        // Start viewer activity monitoring
        this.startViewerMonitoring();
    }

    /**
     * B·∫Øt ƒë·∫ßu streaming t·ª´ stdin (WebSocket binary data)
     * @param {string} roomCode - M√£ ph√≤ng 6 k√Ω t·ª±
     * @returns {Promise<string>} - URL HLS playlist
     */
    async startStreamFromStdin(roomCode) {
        // ‚úÖ WRAP TO√ÄN B·ªò LOGIC TRONG try-catch
        return new Promise(async (resolve, reject) => {
            try {
                // Ki·ªÉm tra n·∫øu stream ƒë√£ t·ªìn t·∫°i
                if (this.activeStreams.has(roomCode)) {
                    console.log(`Stream ${roomCode} already exists`);
                    return resolve(this.getPlaylistUrl(roomCode));
                }

                // T·∫°o th∆∞ m·ª•c cho room
                const roomDir = path.join(this.streamDir, roomCode);
                if (!fs.existsSync(roomDir)) {
                    fs.mkdirSync(roomDir, { recursive: true });
                }

                const playlistPath = path.join(roomDir, 'playlist.m3u8');
                const segmentPattern = path.join(roomDir, 'segment_%03d.ts');

                // FFmpeg command ƒë·ªÉ convert WebM t·ª´ stdin sang HLS
                const ffmpegArgs = [
                    '-i', 'pipe:0',               // Read from stdin
                    '-f', 'webm',                 // Input format t·ª´ MediaRecorder
                    '-c:v', 'libx264',
                    '-c:a', 'aac',
                    '-preset', 'ultrafast',       // Thay v√¨ veryfast ƒë·ªÉ spawn nhanh h∆°n
                    '-tune', 'zerolatency',
                    '-profile:v', 'baseline',
                    '-level', '3.0',
                    '-pix_fmt', 'yuv420p',
                    '-g', '30',
                    '-keyint_min', '30',
                    '-sc_threshold', '0',
                    '-b:v', '2000k',
                    '-maxrate', '2500k',
                    '-bufsize', '3000k',
                    '-b:a', '128k',
                    '-ar', '44100',
                    '-f', 'hls',
                    '-hls_time', '1',
                    '-hls_list_size', '6',
                    '-hls_flags', 'delete_segments+independent_segments',
                    '-hls_segment_type', 'mpegts',
                    '-hls_segment_filename', segmentPattern,
                    '-loglevel', 'warning',       // Gi·∫£m log xu·ªëng warning ƒë·ªÉ d·ªÖ debug
                    playlistPath
                ];

                console.log(`üé¨ Spawning FFmpeg for room ${roomCode}...`);

                let ffmpeg;
                let spawnErrorOccurred = false;
                
                try {
                    ffmpeg = spawn('ffmpeg', ffmpegArgs);
                    
                    // ‚úÖ TH√äM: Check PID ngay sau spawn
                    if (!ffmpeg.pid) {
                        console.error(`‚ùå FFmpeg spawn failed - no PID assigned`);
                        return reject(new Error('FFmpeg spawn failed - no PID assigned'));
                    }
                    
                    console.log(`‚úÖ FFmpeg spawned successfully, PID: ${ffmpeg.pid}`);
                } catch (spawnError) {
                    console.error(`‚ùå FFmpeg spawn failed:`, spawnError);
                    return reject(new Error(`FFmpeg spawn failed: ${spawnError.message}`));
                }
                
                // ‚úÖ TH√äM: Global error handler cho FFmpeg process
                ffmpeg.on('error', (error) => {
                    if (!spawnErrorOccurred) {
                        spawnErrorOccurred = true;
                        console.error(`üí• FFmpeg process error for ${roomCode}:`, error.message);
                        this.activeStreams.delete(roomCode);
                        this.stdinProcesses.delete(roomCode);
                        reject(new Error(`FFmpeg process error: ${error.message}`));
                    }
                });
                
                // ‚úÖ TH√äM: Timeout ƒë·ªÉ detect FFmpeg kh√¥ng kh·ªüi ƒë·ªông ƒë∆∞·ª£c
                const spawnTimeout = setTimeout(() => {
                    if (!spawnErrorOccurred) {
                        spawnErrorOccurred = true;
                        console.error(`‚ùå FFmpeg spawn timeout - process may not have started`);
                        if (ffmpeg && !ffmpeg.killed) {
                            ffmpeg.kill('SIGKILL');
                        }
                        reject(new Error('FFmpeg spawn timeout - process may not have started'));
                    }
                }, 5000); // 5 gi√¢y timeout cho spawn
                
                // ‚úÖ FIX: ƒê·ª£i FFmpeg stdin ready v·ªõi timeout d√†i h∆°n
                console.log(`üîß Waiting for FFmpeg stdin ready for room ${roomCode}...`);
                try {
                    await new Promise((resolveStdin, rejectStdin) => {
                        const stdinTimeout = setTimeout(() => {
                            if (!spawnErrorOccurred) {
                                rejectStdin(new Error('FFmpeg stdin ready timeout after 10 seconds'));
                            }
                        }, 10000); // ‚úÖ TƒÇNG l√™n 10 gi√¢y cho Railway

                        // Check if stdin is immediately writable
                        if (ffmpeg.stdin && ffmpeg.stdin.writable) {
                            console.log(`‚úÖ FFmpeg stdin immediately ready for room ${roomCode}`);
                            clearTimeout(stdinTimeout);
                            clearTimeout(spawnTimeout); // ‚úÖ Clear spawn timeout
                            resolveStdin();
                        } else {
                            // Wait for stdin to become writable
                            let checkCount = 0;
                            const checkStdin = () => {
                                checkCount++;
                                if (ffmpeg.stdin && ffmpeg.stdin.writable) {
                                    console.log(`‚úÖ FFmpeg stdin ready after ${checkCount} checks for room ${roomCode}`);
                                    clearTimeout(stdinTimeout);
                                    clearTimeout(spawnTimeout); // ‚úÖ Clear spawn timeout
                                    resolveStdin();
                                } else if (checkCount < 200) { // Max 200 checks (10 seconds / 50ms)
                                    setTimeout(checkStdin, 50);
                                } else {
                                    clearTimeout(stdinTimeout);
                                    rejectStdin(new Error('FFmpeg stdin never became writable'));
                                }
                            };
                            checkStdin();
                        }
                    });
                } catch (stdinError) {
                    console.error(`‚ùå stdin ready failed:`, stdinError);
                    clearTimeout(spawnTimeout); // ‚úÖ Clear spawn timeout
                    if (ffmpeg && !ffmpeg.killed) {
                        ffmpeg.kill('SIGKILL');
                    }
                    return reject(stdinError);
                }

                // ‚úÖ L∆∞u stdin stream SAU KHI ƒë√£ ready
                this.stdinProcesses.set(roomCode, ffmpeg.stdin);
                console.log(`‚úÖ stdin process registered for room ${roomCode}`);

                // Setup FFmpeg output handlers
                ffmpeg.stdout.on('data', (data) => {
                    const output = data.toString();
                    if (output.trim()) {
                        console.log(`FFmpeg ${roomCode} stdout:`, output.trim());
                    }
                });

                ffmpeg.stderr.on('data', (data) => {
                    const output = data.toString();
                    // Ch·ªâ log nh·ªØng th√¥ng tin quan tr·ªçng
                    if (output.includes('error') || output.includes('Error') || 
                        output.includes('failed') || output.includes('Failed')) {
                        console.error(`‚ùå FFmpeg ${roomCode} error:`, output.trim());
                    } else if (output.includes('frame=') || output.includes('time=')) {
                        // Log progress m·ªói 10 gi√¢y
                        const now = Date.now();
                        const lastLog = this.lastProgressLog.get(roomCode) || 0;
                        if (now - lastLog > 10000) {
                            console.log(`üìä FFmpeg ${roomCode} progress:`, output.trim().split('\n')[0]);
                            this.lastProgressLog.set(roomCode, now);
                        }
                    } else if (output.trim()) {
                        console.log(`üîß FFmpeg ${roomCode}:`, output.trim());
                    }
                });

                ffmpeg.on('close', (code) => {
                    console.log(`üèÅ FFmpeg ${roomCode} exited with code ${code}`);
                    this.activeStreams.delete(roomCode);
                    this.stdinProcesses.delete(roomCode);
                    this.lastProgressLog.delete(roomCode);

                    if (code !== 0 && code !== null) {
                        console.error(`‚ùå FFmpeg ${roomCode} exited with error code ${code}`);
                    }

                    setTimeout(() => {
                        this.cleanupRoom(roomCode);
                    }, 30000);
                });

                // L∆∞u process
                this.activeStreams.set(roomCode, ffmpeg);
                console.log(`‚úÖ FFmpeg process registered for room ${roomCode}`);

                // ‚úÖ GI·∫¢M th·ªùi gian ch·ªù initialization xu·ªëng
                console.log(`‚è≥ Waiting 500ms for FFmpeg initialization...`);
                await new Promise(resolveInit => setTimeout(resolveInit, 500));

                // ‚úÖ ƒê·ª£i playlist ƒë∆∞·ª£c t·∫°o v·ªõi timeout d√†i h∆°n
                console.log(`üîç Waiting for playlist creation at: ${playlistPath}`);
                try {
                    await new Promise((resolvePlaylist, rejectPlaylist) => {
                        let checkCount = 0;
                        const checkInterval = setInterval(() => {
                            checkCount++;

                            if (checkCount % 10 === 0) {
                                console.log(`üìã Check #${checkCount}, exists: ${fs.existsSync(playlistPath)}`);
                            }

                            if (fs.existsSync(playlistPath)) {
                                clearInterval(checkInterval);

                                // Get dynamic server address
                                const serverAddress = process.env.DOMAIN || 
                                                    `http://localhost:${process.env.PORT || 8080}`;
                                const hlsUrl = `${serverAddress}/streams/${roomCode}/playlist.m3u8`;
                                const watchUrl = `${serverAddress}/watch/${roomCode}`;

                                console.log(`üì∫ HLS playlist ready for room ${roomCode}: ${hlsUrl}`);

                                // Notify via HTTP
                                this.notifyStreamReady(serverAddress, roomCode, hlsUrl, watchUrl);

                                // ‚úÖ Notify Web Client qua WebSocket
                                this.notifyWebClientStreamReady(roomCode, hlsUrl, watchUrl);

                                resolvePlaylist();
                            }
                        }, 200); // Check m·ªói 200ms

                        // ‚úÖ TƒÇNG timeout l√™n 15 gi√¢y cho Railway
                        setTimeout(() => {
                            clearInterval(checkInterval);
                            console.error(`‚ùå Playlist timeout after ${checkCount} checks for room ${roomCode}`);
                            rejectPlaylist(new Error('Playlist creation timeout after 15 seconds'));
                        }, 15000);
                    });
                } catch (playlistError) {
                    console.error(`‚ùå Playlist creation failed:`, playlistError);
                    // Cleanup FFmpeg
                    if (ffmpeg && !ffmpeg.killed) {
                        ffmpeg.kill('SIGTERM');
                    }
                    this.activeStreams.delete(roomCode);
                    this.stdinProcesses.delete(roomCode);
                    return reject(playlistError);
                }

                // ‚úÖ SUCCESS - resolve v·ªõi playlist URL
                const playlistUrl = this.getPlaylistUrl(roomCode);
                console.log(`‚úÖ Stream started successfully for room ${roomCode}: ${playlistUrl}`);
                resolve(playlistUrl);

            } catch (error) {
                console.error(`‚ùå Error in startStreamFromStdin for ${roomCode}:`, error);
                reject(error);
            }
        });
    }

    /**
     * Ghi chunk data v√†o stdin c·ªßa FFmpeg v·ªõi backpressure handling
     * @param {string} roomCode - M√£ ph√≤ng
     * @param {Buffer} chunk - Binary data chunk
     * @returns {boolean} - true n·∫øu c√≥ th·ªÉ ti·∫øp t·ª•c ghi, false n·∫øu c·∫ßn ƒë·ª£i
     */
    writeChunk(roomCode, chunk) {
        const stdin = this.stdinProcesses.get(roomCode);
        if (stdin && !stdin.destroyed) {
            try {
                const canWrite = stdin.write(chunk);
                if (!canWrite) {
                    // Buffer ƒë·∫ßy - c·∫ßn backpressure handling
                    console.warn(`‚ö†Ô∏è stdin buffer full for room ${roomCode}, waiting for drain...`);
                    
                    // Emit event ƒë·ªÉ client c√≥ th·ªÉ pause MediaRecorder
                    stdin.once('drain', () => {
                        console.log(`‚úÖ stdin drained for room ${roomCode}, can resume`);
                        // C√≥ th·ªÉ emit event ƒë·ªÉ client resume MediaRecorder
                    });
                    
                    return false; // B√°o hi·ªáu c·∫ßn ƒë·ª£i
                }
                return true; // C√≥ th·ªÉ ti·∫øp t·ª•c ghi
            } catch (error) {
                console.error(`Error writing chunk to ${roomCode}:`, error);
                return false;
            }
        } else {
            console.warn(`No stdin process found for room ${roomCode}`);
            return false;
        }
    }

    /**
     * B·∫Øt ƒë·∫ßu streaming cho room
     * @param {string} roomCode - M√£ ph√≤ng 6 k√Ω t·ª±
     * @param {string} inputUrl - URL WebRTC stream (t·ª´ web client)
     * @returns {Promise<string>} - URL HLS playlist
     */
    async startStream(roomCode, inputUrl) {
        try {
            // Ki·ªÉm tra n·∫øu stream ƒë√£ t·ªìn t·∫°i
            if (this.activeStreams.has(roomCode)) {
                console.log(`Stream ${roomCode} already exists`);
                return this.getPlaylistUrl(roomCode);
            }

            // T·∫°o th∆∞ m·ª•c cho room
            const roomDir = path.join(this.streamDir, roomCode);
            if (!fs.existsSync(roomDir)) {
                fs.mkdirSync(roomDir, { recursive: true });
            }

            const playlistPath = path.join(roomDir, 'playlist.m3u8');
            const segmentPattern = path.join(roomDir, 'segment_%03d.ts');

            // FFmpeg command ƒë·ªÉ convert WebRTC sang HLS v·ªõi t·ªëi ∆∞u cho low latency
            const ffmpegArgs = [
                '-i', inputUrl,
                '-c:v', 'libx264',
                '-c:a', 'aac',
                '-preset', 'veryfast',        // C√¢n b·∫±ng gi·ªØa t·ªëc ƒë·ªô v√† ch·∫•t l∆∞·ª£ng
                '-tune', 'zerolatency',       // T·ªëi ∆∞u cho streaming real-time
                '-profile:v', 'baseline',     // T∆∞∆°ng th√≠ch t·ªët v·ªõi mobile
                '-level', '3.0',              // T∆∞∆°ng th√≠ch r·ªông
                '-pix_fmt', 'yuv420p',        // Pixel format t∆∞∆°ng th√≠ch
                '-g', '30',                   // GOP size = 30 frames
                '-keyint_min', '30',          // Minimum keyframe interval
                '-sc_threshold', '0',         // Disable scene change detection
                '-b:v', '2000k',              // TƒÉng t·ª´ 1000k l√™n 2000k ƒë·ªÉ gi·∫£m keyframe interval
                '-maxrate', '2500k',          // TƒÉng t·ª´ 1200k l√™n 2500k
                '-bufsize', '3000k',          // TƒÉng buffer size t∆∞∆°ng ·ª©ng
                '-b:a', '128k',               // Audio bitrate 128kbps
                '-ar', '44100',               // Audio sample rate
                '-f', 'hls',
                '-hls_time', '1',             // Gi·∫£m t·ª´ 2s xu·ªëng 1s ƒë·ªÉ gi·∫£m latency
                '-hls_list_size', '6',        // Gi·ªØ 6 segments (6 gi√¢y buffer thay v√¨ 12s)
                '-hls_flags', 'delete_segments+independent_segments',
                '-hls_segment_type', 'mpegts',
                '-hls_segment_filename', segmentPattern,
                '-loglevel', 'info',          // Log level ƒë·ªÉ debug
                playlistPath
            ];

            console.log(`Starting FFmpeg for room ${roomCode}:`, ffmpegArgs.join(' '));

            const ffmpeg = spawn('ffmpeg', ffmpegArgs);
            
            ffmpeg.stdout.on('data', (data) => {
                console.log(`FFmpeg ${roomCode} stdout:`, data.toString());
            });

            ffmpeg.stderr.on('data', (data) => {
                const output = data.toString();
                // Ch·ªâ log nh·ªØng th√¥ng tin quan tr·ªçng, kh√¥ng spam console
                if (output.includes('error') || output.includes('Error') || 
                    output.includes('failed') || output.includes('Failed')) {
                    console.error(`‚ùå FFmpeg ${roomCode} error:`, output.trim());
                } else if (output.includes('frame=') || output.includes('time=')) {
                    // Log progress m·ªói 10 gi√¢y thay v√¨ random
                    const now = Date.now();
                    const lastLog = this.lastProgressLog.get(roomCode) || 0;
                    if (now - lastLog > 10000) { // 10 gi√¢y
                        console.log(`üìä FFmpeg ${roomCode} progress:`, output.trim().split('\n')[0]);
                        this.lastProgressLog.set(roomCode, now);
                    }
                } else {
                    console.log(`üîß FFmpeg ${roomCode}:`, output.trim());
                }
            });

            ffmpeg.on('close', (code) => {
                console.log(`üèÅ FFmpeg ${roomCode} exited with code ${code}`);
                this.activeStreams.delete(roomCode);
                this.lastProgressLog.delete(roomCode); // Cleanup progress log tracking
                
                // Ch·ªâ cleanup n·∫øu exit code kh√¥ng ph·∫£i 0 (l·ªói) ho·∫∑c SIGTERM (d·ª´ng b√¨nh th∆∞·ªùng)
                if (code !== 0 && code !== null) {
                    console.error(`‚ùå FFmpeg ${roomCode} exited with error code ${code}`);
                }
                
                // Delay cleanup ƒë·ªÉ client c√≥ th·ªÉ t·∫£i segment cu·ªëi
                setTimeout(() => {
                    this.cleanupRoom(roomCode);
                }, 30000); // 30 gi√¢y - tƒÉng t·ª´ 10s ƒë·ªÉ tr√°nh viewer b·ªã 404
            });

            ffmpeg.on('error', (error) => {
                console.error(`üí• FFmpeg ${roomCode} process error:`, error.message);
                this.activeStreams.delete(roomCode);
                this.lastProgressLog.delete(roomCode); // Cleanup progress log tracking
                
                // Cleanup ngay l·∫≠p t·ª©c khi c√≥ l·ªói process
                setTimeout(() => {
                    this.cleanupRoom(roomCode);
                }, 2000);
            });

            // L∆∞u process
            this.activeStreams.set(roomCode, ffmpeg);

            // ƒê·ª£i FFmpeg kh·ªüi t·∫°o v√† t·∫°o playlist v·ªõi timeout
            await new Promise((resolve, reject) => {
                const checkInterval = setInterval(() => {
                    if (fs.existsSync(playlistPath)) {
                        clearInterval(checkInterval);
                        console.log(`‚úÖ Playlist created for room ${roomCode}`);
                        resolve();
                    }
                }, 500);

                // Timeout sau 15 gi√¢y
                const timeout = setTimeout(() => {
                    clearInterval(checkInterval);
                    console.error(`‚ùå FFmpeg did not create playlist.m3u8 for room ${roomCode} in time`);
                    
                    // Cleanup failed stream
                    if (this.activeStreams.has(roomCode)) {
                        const failedFFmpeg = this.activeStreams.get(roomCode);
                        failedFFmpeg.kill('SIGTERM');
                        this.activeStreams.delete(roomCode);
                        this.lastProgressLog.delete(roomCode);
                    }
                    
                    reject(new Error(`FFmpeg startup failed for room ${roomCode}: playlist not created in time`));
                }, 15000);

                // Cleanup timeout if resolved early
                const originalResolve = resolve;
                resolve = () => {
                    clearTimeout(timeout);
                    originalResolve();
                };
            });

            return this.getPlaylistUrl(roomCode);

        } catch (error) {
            console.error(`Error starting stream for ${roomCode}:`, error);
            throw error;
        }
    }

    /**
     * D·ª´ng streaming cho room
     * @param {string} roomCode - M√£ ph√≤ng
     */
    stopStream(roomCode) {
        // ƒê√≥ng stdin stream tr∆∞·ªõc khi kill process
        const stdin = this.stdinProcesses.get(roomCode);
        if (stdin && !stdin.destroyed) {
            console.log(`Closing stdin stream for room ${roomCode}`);
            stdin.end();
            this.stdinProcesses.delete(roomCode);
        }

        const ffmpeg = this.activeStreams.get(roomCode);
        if (ffmpeg) {
            console.log(`Stopping stream for room ${roomCode}`);
            ffmpeg.kill('SIGTERM');
            this.activeStreams.delete(roomCode);
            this.lastProgressLog.delete(roomCode);
            
            // Cleanup sau 30 gi√¢y - tƒÉng t·ª´ 5s ƒë·ªÉ tr√°nh viewer b·ªã 404
            setTimeout(() => {
                this.cleanupRoom(roomCode);
            }, 30000);
        }
    }

    /**
     * L·∫•y URL playlist HLS
     * @param {string} roomCode - M√£ ph√≤ng
     * @returns {string} - URL playlist
     */
    getPlaylistUrl(roomCode) {
        return `/streams/${roomCode}/playlist.m3u8`;
    }

    /**
     * L·∫•y URL trang viewer
     * @param {string} roomCode - M√£ ph√≤ng
     * @returns {string} - URL trang viewer
     */
    getViewerUrl(roomCode) {
        return `/watch/${roomCode}`;
    }

    /**
     * Ki·ªÉm tra stream c√≥ ƒëang ho·∫°t ƒë·ªông kh√¥ng
     * @param {string} roomCode - M√£ ph√≤ng
     * @returns {boolean}
     */
    isStreamActive(roomCode) {
        return this.activeStreams.has(roomCode);
    }

    /**
     * D·ªçn d·∫πp th∆∞ m·ª•c room
     * @param {string} roomCode - M√£ ph√≤ng
     */
    cleanupRoom(roomCode) {
        const roomDir = path.join(this.streamDir, roomCode);
        if (fs.existsSync(roomDir)) {
            try {
                fs.rmSync(roomDir, { recursive: true, force: true });
                console.log(`Cleaned up room directory: ${roomCode}`);
            } catch (error) {
                console.error(`Error cleaning up room ${roomCode}:`, error);
            }
        }
    }

    /**
     * L·∫•y danh s√°ch streams ƒëang ho·∫°t ƒë·ªông
     * @returns {Array<string>} - Danh s√°ch room codes
     */
    getActiveStreams() {
        return Array.from(this.activeStreams.keys());
    }

    /**
     * Th√™m viewer cho room
     * @param {string} roomCode - M√£ ph√≤ng
     */
    addViewer(roomCode) {
        const currentCount = this.viewerCounts.get(roomCode) || 0;
        this.viewerCounts.set(roomCode, currentCount + 1);
        this.lastViewerActivity.set(roomCode, Date.now());
        
        // Clear auto-stop timer if exists
        if (this.autoStopTimers.has(roomCode)) {
            clearTimeout(this.autoStopTimers.get(roomCode));
            this.autoStopTimers.delete(roomCode);
        }
        
        console.log(`üë• Viewer joined room ${roomCode}. Total viewers: ${currentCount + 1}`);
        
        // ‚úÖ TH√äM: Notify Web Client about viewer count
        this.notifyViewerCountUpdate(roomCode, currentCount + 1);
    }

    /**
     * X√≥a viewer kh·ªèi room
     * @param {string} roomCode - M√£ ph√≤ng
     */
    removeViewer(roomCode) {
        const currentCount = this.viewerCounts.get(roomCode) || 0;
        const newCount = Math.max(0, currentCount - 1);
        this.viewerCounts.set(roomCode, newCount);
        this.lastViewerActivity.set(roomCode, Date.now());
        
        console.log(`üë• Viewer left room ${roomCode}. Total viewers: ${newCount}`);
        
        // ‚úÖ TH√äM: Notify Web Client about viewer count
        this.notifyViewerCountUpdate(roomCode, newCount);
        
        // Start auto-stop timer if no viewers
        if (newCount === 0 && this.activeStreams.has(roomCode)) {
            this.scheduleAutoStop(roomCode);
        }
    }

    /**
     * C·∫≠p nh·∫≠t ho·∫°t ƒë·ªông viewer (khi request HLS segments)
     * @param {string} roomCode - M√£ ph√≤ng
     */
    updateViewerActivity(roomCode) {
        this.lastViewerActivity.set(roomCode, Date.now());
        
        // Ensure viewer count is at least 1 if there's activity
        if (!this.viewerCounts.has(roomCode) || this.viewerCounts.get(roomCode) === 0) {
            this.addViewer(roomCode);
        }
    }

    /**
     * L√™n l·ªãch auto-stop stream khi kh√¥ng c√≥ viewers
     * @param {string} roomCode - M√£ ph√≤ng
     */
    scheduleAutoStop(roomCode) {
        // Clear existing timer
        if (this.autoStopTimers.has(roomCode)) {
            clearTimeout(this.autoStopTimers.get(roomCode));
        }
        
        // Set 30-second timer
        const timer = setTimeout(() => {
            const viewerCount = this.viewerCounts.get(roomCode) || 0;
            if (viewerCount === 0 && this.activeStreams.has(roomCode)) {
                console.log(`‚è∞ Auto-stopping stream ${roomCode} - no viewers for 30 seconds`);
                this.stopStream(roomCode);
            }
        }, 30000); // 30 seconds
        
        this.autoStopTimers.set(roomCode, timer);
        console.log(`‚è∞ Auto-stop scheduled for room ${roomCode} in 30 seconds`);
    }

    /**
     * B·∫Øt ƒë·∫ßu monitoring viewer activity
     */
    startViewerMonitoring() {
        // Check every 60 seconds for inactive viewers
        setInterval(() => {
            const now = Date.now();
            const inactiveThreshold = 60000; // 60 seconds
            
            for (const [roomCode, lastActivity] of this.lastViewerActivity.entries()) {
                if (now - lastActivity > inactiveThreshold) {
                    const viewerCount = this.viewerCounts.get(roomCode) || 0;
                    if (viewerCount > 0) {
                        console.log(`üë• Detected inactive viewers in room ${roomCode}, resetting count`);
                        this.viewerCounts.set(roomCode, 0);
                        if (this.activeStreams.has(roomCode)) {
                            this.scheduleAutoStop(roomCode);
                        }
                    }
                }
            }
        }, 60000); // Check every minute
    }

    /**
     * L·∫•y s·ªë l∆∞·ª£ng viewers hi·ªán t·∫°i
     * @param {string} roomCode - M√£ ph√≤ng
     * @returns {number} - S·ªë l∆∞·ª£ng viewers
     */
    getViewerCount(roomCode) {
        return this.viewerCounts.get(roomCode) || 0;
    }

    /**
     * Notify Web Client v·ªÅ viewer count update
     * @param {string} roomCode - M√£ ph√≤ng
     * @param {number} viewerCount - S·ªë l∆∞·ª£ng viewers
     */
    notifyViewerCountUpdate(roomCode, viewerCount) {
        try {
            if (!this.rooms) {
                console.warn('‚ö†Ô∏è Rooms reference not available');
                return;
            }
            
            const room = this.rooms.get(roomCode);
            
            if (room && room.web && room.web.readyState === 1) { // WebSocket.OPEN
                const viewerUpdateMessage = {
                    type: 'viewer_count_update',
                    roomCode: roomCode,
                    viewerCount: viewerCount,
                    timestamp: new Date().toISOString()
                };
                
                room.web.send(JSON.stringify(viewerUpdateMessage));
                console.log(`üì§ Sent viewer count update to Web Client: ${viewerCount} viewers for room ${roomCode}`);
            }
        } catch (error) {
            console.error('‚ùå Error notifying viewer count update:', error.message);
        }
    }

    /**
     * Notify Web Client qua WebSocket khi stream ready
     * @param {string} roomCode - M√£ ph√≤ng
     * @param {string} hlsUrl - URL HLS playlist
     * @param {string} watchUrl - URL trang xem
     */
    notifyWebClientStreamReady(roomCode, hlsUrl, watchUrl) {
        try {
            if (!this.rooms) {
                console.warn('‚ö†Ô∏è Rooms reference not available');
                return;
            }
            
            const room = this.rooms.get(roomCode);
            
            if (room && room.web && room.web.readyState === 1) { // WebSocket.OPEN
                const streamReadyMessage = {
                    type: 'stream_ready',
                    roomCode: roomCode,
                    hlsUrl: hlsUrl,
                    watchPageUrl: watchUrl,
                    timestamp: new Date().toISOString()
                };
                
                room.web.send(JSON.stringify(streamReadyMessage));
                console.log(`üì§ Sent stream_ready to Web Client for room ${roomCode}`);
                
                // ‚úÖ TH√äM: Notify Android client too if available
                if (room.android && room.android.readyState === 1) {
                    room.android.send(JSON.stringify(streamReadyMessage));
                    console.log(`üì§ Sent stream_ready to Android Client for room ${roomCode}`);
                }
            } else {
                console.warn(`‚ö†Ô∏è Web Client not available for room ${roomCode}`);
            }
        } catch (error) {
            console.error('‚ùå Error notifying Web Client:', error.message);
        }
    }

    /**
     * G·ª≠i th√¥ng b√°o stream ready ƒë·∫øn server endpoint
     * @param {string} serverAddress - ƒê·ªãa ch·ªâ server
     * @param {string} roomCode - M√£ ph√≤ng
     * @param {string} hlsUrl - URL HLS playlist
     * @param {string} watchUrl - URL trang xem
     */
    notifyStreamReady(serverAddress, roomCode, hlsUrl, watchUrl) {
        try {
            const notifyUrl = new URL(`${serverAddress}/api/notify-stream-ready`);
            const protocol = notifyUrl.protocol === 'https:' ? https : http;
            
            const postData = JSON.stringify({ 
                roomCode, 
                hlsUrl, 
                watchPageUrl: watchUrl 
            });
            
            const req = protocol.request({
                hostname: notifyUrl.hostname,
                port: notifyUrl.port,
                path: notifyUrl.pathname,
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Content-Length': Buffer.byteLength(postData)
                }
            }, (res) => {
                console.log(`‚úÖ Notify stream ready response: ${res.statusCode}`);
            });
            
            req.on('error', (err) => {
                console.error('‚ùå Failed to notify stream ready:', err.message);
            });
            
            req.write(postData);
            req.end();
            
        } catch (error) {
            console.error('‚ùå Error creating notify request:', error.message);
        }
    }
}

module.exports = StreamingService;